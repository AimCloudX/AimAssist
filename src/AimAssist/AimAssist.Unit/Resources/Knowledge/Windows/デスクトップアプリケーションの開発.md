# グローバルホットキー

## 1. グローバルホットキーの基本概念

グローバルホットキーは、アプリケーションがアクティブでない場合でも、システム全体で機能するキーボードショートカットです。


## 2. .NETを使用した実装

```csharp
public class GlobalHotKeyForm : Form
{
    [DllImport("user32.dll")]
    public static extern bool RegisterHotKey(IntPtr hWnd, int id, uint fsModifiers, uint vk);

    [DllImport("user32.dll")]
    public static extern bool UnregisterHotKey(IntPtr hWnd, int id);

    protected override void OnLoad(EventArgs e)
    {
        base.OnLoad(e);
        RegisterHotKey(this.Handle, 1, (uint)KeyModifiers.Alt | (uint)KeyModifiers.Control, (uint)Keys.A);
    }

    protected override void WndProc(ref Message m)
    {
        if (m.Msg == 0x0312) // WM_HOTKEY
        {
            if (m.WParam.ToInt32() == 1) // ID 1のホットキー
            {
                // ホットキーが押された時の処理
            }
        }
        base.WndProc(ref m);
    }

    protected override void OnFormClosing(FormClosingEventArgs e)
    {
        UnregisterHotKey(this.Handle, 1);
        base.OnFormClosing(e);
    }
}

[Flags]
public enum KeyModifiers
{
    None = 0,
    Alt = 1,
    Control = 2,
    Shift = 4,
    Windows = 8
}
```

## 3. 注意点とベストプラクティス

1. システムやほかのアプリケーションとの競合を避けるため、一般的に使用されているキーの組み合わせは避けましょう。
2. ユーザーがホットキーをカスタマイズできるようにすることを検討してください。
3. 国際化対応の際は、異なるキーボードレイアウトを考慮してください。
4. ホットキーの一覧と説明をユーザーが簡単に確認できるようにしましょう。
5. アプリケーションの終了時には、必ずホットキーを解除してください。

---

# アクセラレーターキー

アクセラレーターキーは、アプリケーション内でキーボードショートカットを提供するためのWindowsの機能です。これらは主にメニュー項目やボタンなどのUI要素に関連付けられます。

## 2. アクセラレーターキーの実装 (Win32 API)

### 2.1 アクセラレーターテーブルの定義

```cpp
// リソースファイル (.rc) 内で定義
MYACCEL ACCELERATORS
BEGIN
    "^C",   ID_EDIT_COPY
    "^V",   ID_EDIT_PASTE
    VK_F5,  ID_REFRESH,  VIRTKEY
END
```

### 2.2 アクセラレーターテーブルの読み込みと使用

```cpp
HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(MYACCEL));

// メッセージループ内で
MSG msg;
while (GetMessage(&msg, NULL, 0, 0))
{
    if (!TranslateAccelerator(hWnd, hAccel, &msg))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}
```

## 3. .NET Windowsフォームでの実装

.NET Windowsフォームでは、メニュー項目の`ShortcutKeys`プロパティを使用してアクセラレーターキーを定義します。

```csharp
menuItemCopy.ShortcutKeys = Keys.Control | Keys.C;
menuItemPaste.ShortcutKeys = Keys.Control | Keys.V;
```

## 4. アクセラレーターキーの利点

1. **使いやすさ**: ユーザーが素早くアクションを実行できます。
2. **標準化**: Windowsアプリケーション間で一貫性のあるショートカットを提供できます。
3. **学習容易性**: メニュー項目に表示されるため、ユーザーが覚えやすくなります。

## 5. ベストプラクティス

1. 一般的なショートカット（Ctrl+C for コピーなど）には標準的な組み合わせを使用する。
2. アクセラレーターキーをメニュー項目に表示して、ユーザーに周知する。
3. 複雑な操作や頻繁に使用される機能にアクセラレーターキーを割り当てる。
4. 国際化を考慮し、キーボードレイアウトに依存しないキーの組み合わせを選択する。

---

# システムトレイ

システムトレイ（正式名称：通知領域）は、Windows タスクバーの右端にある小さなアイコンを表示する領域です。アプリケーションはここにアイコンを配置し、ステータス情報の表示やクイックアクセスメニューの提供などを行います。

## 1. システムトレイの主な用途

1. アプリケーションの最小化
2. バックグラウンド実行中のアプリケーションの状態表示
3. クイックアクセスメニューの提供
4. 通知の表示

## 2. Win32 APIでの実装

### 2.1 システムトレイアイコンの追加

```cpp
#include <windows.h>
#include <shellapi.h>

NOTIFYICONDATA nid = {0};
nid.cbSize = sizeof(NOTIFYICONDATA);
nid.hWnd = hWnd;  // ウィンドウハンドル
nid.uID = 1;      // 一意の識別子
nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
nid.uCallbackMessage = WM_APP + 1;  // カスタムメッセージ
nid.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON));
lstrcpy(nid.szTip, L"My Application");

Shell_NotifyIcon(NIM_ADD, &nid);
```

### 2.2 コンテキストメニューの処理

```cpp
case WM_APP + 1:  // カスタムメッセージ
    if (lParam == WM_RBUTTONUP)
    {
        POINT pt;
        GetCursorPos(&pt);
        HMENU hMenu = CreatePopupMenu();
        AppendMenu(hMenu, MF_STRING, IDM_EXIT, L"終了");
        SetForegroundWindow(hWnd);
        TrackPopupMenu(hMenu, TPM_RIGHTALIGN | TPM_BOTTOMALIGN, pt.x, pt.y, 0, hWnd, NULL);
        DestroyMenu(hMenu);
    }
    break;
```

### 2.3 システムトレイアイコンの削除

```cpp
Shell_NotifyIcon(NIM_DELETE, &nid);
```

## 3. .NET Windowsフォームでの実装

### 3.1 システムトレイアイコンの追加

```csharp
using System.Windows.Forms;

NotifyIcon notifyIcon = new NotifyIcon();
notifyIcon.Icon = new Icon("path/to/icon.ico");
notifyIcon.Visible = true;
notifyIcon.Text = "My Application";
```

### 3.2 コンテキストメニューの追加

```csharp
ContextMenuStrip contextMenu = new ContextMenuStrip();
contextMenu.Items.Add("設定", null, OnSettingsClick);
contextMenu.Items.Add("終了", null, OnExitClick);
notifyIcon.ContextMenuStrip = contextMenu;
```

### 3.3 通知の表示

```csharp
notifyIcon.ShowBalloonTip(3000, "タイトル", "メッセージ内容", ToolTipIcon.Info);
```

## 4. ベストプラクティス

1. アイコンは16x16ピクセルと32x32ピクセルの両方のサイズを用意する。
2. ツールチップテキストは簡潔かつ明確にする。
3. コンテキストメニューは使いやすく、重要な機能にクイックアクセスできるようにする。
4. 通知は控えめに使用し、重要な情報のみを表示する。
5. アプリケーション終了時には必ずアイコンを削除する。

## 5. 注意点

1. システムトレイの領域は限られているため、常時表示が必要ない場合は自動的に非表示にすることを検討する。
2. ユーザーがシステムトレイアイコンを非表示にできるようにする。
3. 頻繁な通知はユーザーにとって煩わしい可能性があるため、適切に使用する。

---

# ダイアログ

## 1. モーダルダイアログとモーダレスダイアログ

## モーダルダイアログ
- ユーザーの注意を完全に占有し、メインウィンドウとの対話を阻止します。
- ダイアログを閉じるまで、親ウィンドウとの対話ができません。

## モーダレスダイアログ
- 親ウィンドウとの対話を許可しながら表示されます。
- ユーザーは自由にメインウィンドウと対話できます。

## 2. 使用シナリオ

### モーダルダイアログの適用例
- 重要な決定や確認が必要な場合（例：保存せずに終了する確認）
- エラーメッセージの表示
- 即時の入力が必要な場合（例：ファイル名の入力）

### モーダレスダイアログの適用例
- 検索ダイアログ
- ツールパレット
- プロパティウィンドウ

## 3. .NET Windowsフォームでの実装

### 3.1 モーダルダイアログの表示

```csharp
using (Form dialogForm = new Form())
{
    dialogForm.Text = "モーダルダイアログ";
    // ダイアログの内容を設定
    DialogResult result = dialogForm.ShowDialog();
    if (result == DialogResult.OK)
    {
        // OKボタンが押された場合の処理
    }
}
```

### 3.2 モーダレスダイアログの表示

```csharp
Form dialogForm = new Form();
dialogForm.Text = "モーダレスダイアログ";
// ダイアログの内容を設定
dialogForm.FormClosed += (s, args) => dialogForm.Dispose();
dialogForm.Show();
```

## 4. ベストプラクティス

1. モーダルダイアログは必要最小限に抑える。
2. モーダルダイアログには常にキャンセルオプションを用意する。
3. モーダレスダイアログは親ウィンドウの上に表示し、親ウィンドウに従って最小化・復元する。
4. ダイアログのサイズは適切に設定し、必要に応じてリサイズ可能にする。
5. キーボードナビゲーション（Tabキーでのフォーカス移動など）を適切に実装する。

## 5. アクセシビリティの考慮

1. スクリーンリーダーでの読み上げに配慮したラベル付けを行う。
2. キーボードのみでの操作が可能なようにする。
3. 適切なコントラストと文字サイズを使用する。

---

# WebView

WebViewは、デスクトップアプリケーション内にウェブコンテンツを埋め込むためのコントロールです。これにより、HTML、CSS、JavaScriptを使用してアプリケーションの一部またはすべてを構築することが可能になります。

## 1. Edge WebView2
- 最新のChromiumベースのEdgeブラウザエンジンを使用
- クロスプラットフォーム対応と優れたパフォーマンス

## 2. Edge WebView2の実装

### 2.1 必要な環境
- WebView2 Runtime のインストール
- WebView2 SDK の参照

### 2.2 C#での基本的な実装例

```csharp
using Microsoft.Web.WebView2.Core;
using Microsoft.Web.WebView2.WinForms;

public partial class Form1 : Form
{
    private WebView2 webView;

    public Form1()
    {
        InitializeComponent();
        InitializeAsync();
    }

    async void InitializeAsync()
    {
        webView = new WebView2();
        webView.Dock = DockStyle.Fill;
        this.Controls.Add(webView);

        await webView.EnsureCoreWebView2Async(null);
        webView.CoreWebView2.Navigate("https://www.example.com");
    }
}
```

### 2.3 JavaScript との連携

```csharp
// C# から JavaScript を実行
await webView.CoreWebView2.ExecuteScriptAsync("alert('Hello from C#!');");

// JavaScript から C# を呼び出す
webView.CoreWebView2.AddHostObjectToScript("hostObject", new HostObject());
webView.CoreWebView2.AddScriptToExecuteOnDocumentCreatedAsync(
    "window.hostObject.sayHello('WebView2');");

public class HostObject
{
    public void SayHello(string name)
    {
        MessageBox.Show($"Hello, {name}!");
    }
}
```

## 3. WebViewの主な用途

1. ハイブリッドアプリケーションの開発
2. ウェブコンテンツの表示
3. HTML/CSS/JavaScriptを使用したUIの構築
4. オフラインでのウェブアプリケーションの実行

## 4. WebViewのメリット

1. クロスプラットフォーム開発の容易さ
2. Web技術を活用した豊富なUIの実現
3. 既存のWebアプリケーションの再利用
4. 頻繁な更新が必要な部分をWebViewで実装することによる柔軟性の向上

## 5. WebViewの注意点

1. セキュリティ：信頼できないコンテンツの表示には注意が必要
2. パフォーマンス：ネイティブコントロールに比べて若干の性能低下の可能性
3. メモリ使用量：WebViewは比較的大きなメモリを消費する
4. 互換性：異なるバージョンのWebView2 Runtimeでの動作確認が必要

## 6. ベストプラクティス

1. 最新のWebView2を使用する
2. セキュリティポリシーを適切に設定する
3. エラーハンドリングを適切に実装する
4. 大きなデータの受け渡しには非同期通信を使用する
5. アプリケーションの要件に応じて、WebViewとネイティブコントロールを適切に使い分ける

## 8.参考リンク
- [Microsoft Edge WebView2 | Microsoft Edge Developer](https://developer.microsoft.com/ja-jp/microsoft-edge/webview2/?form=MA13LH)
- [C# WebView2を通じてWebサーバーなしでJavaScriptからローカルファイルを読み書き](https://chishiki21.blogspot.com/2021/10/step-by-step-webview2webjavascript.html)
- [📚ブラウザの仕組みを学ぶ](https://zenn.dev/silverbirder/articles/e10295948e17ca)

---
# Windows マルチスレッディングとタスク並列処理ガイド

## 1. 基本概念

マルチスレッディングは、プログラムの複数の部分を同時に実行することで、アプリケーションのパフォーマンスと応答性を向上させる技術です。

## 2. マルチスレッディングの利点

1. 応答性の向上：UIスレッドをブロックせずに長時間の処理を実行できる
2. パフォーマンスの向上：複数のCPUコアを活用できる
3. リソースの効率的な利用：I/O待ち時間中に他の処理を実行できる

## 3. C#での実装例

### 3.1 Thread クラスを使用した基本的なスレッド作成

```csharp
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        Thread thread = new Thread(DoWork);
        thread.Start();
        Console.WriteLine("メインスレッドで作業中");
        thread.Join(); // スレッドの終了を待つ
    }

    static void DoWork()
    {
        Console.WriteLine("別スレッドで作業中");
        Thread.Sleep(1000); // 作業をシミュレート
    }
}
```

### 3.2 Task クラスを使用した非同期処理

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.WriteLine("タスク開始前");
        await DoWorkAsync();
        Console.WriteLine("タスク終了後");
    }

    static async Task DoWorkAsync()
    {
        await Task.Delay(1000); // 非同期の待機をシミュレート
        Console.WriteLine("非同期作業完了");
    }
}
```

### 3.3 Parallel クラスを使用した並列処理

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Parallel.For(0, 10, i =>
        {
            Console.WriteLine($"並列処理 {i}");
        });
    }
}
```

## 4. UIスレッドの考慮事項

Windows Forms や WPF アプリケーションでは、UIの更新は必ずUIスレッドで行う必要があります。

```csharp
private async void button1_Click(object sender, EventArgs e)
{
    await Task.Run(() => {
        // 長時間の処理
    });
    
    // UIの更新
    this.Text = "処理完了";
}
```

## 5. 同期とスレッドセーフティ

複数のスレッドが共有リソースにアクセスする場合、適切な同期メカニズムを使用する必要があります。

```csharp
using System;
using System.Threading;

class SharedResource
{
    private int _value = 0;
    private readonly object _lock = new object();

    public void Increment()
    {
        lock (_lock)
        {
            _value++;
        }
    }

    public int GetValue()
    {
        lock (_lock)
        {
            return _value;
        }
    }
}
```

## 6. 注意点とベストプラクティス

1. デッドロックを避ける：ロックの順序を一貫させる
2. スレッドプールを効率的に使用する：長時間実行されるスレッドには注意
3. 過度のスレッド作成を避ける：スレッド作成のオーバーヘッドを考慮する
4. 適切な粒度で並列化する：細かすぎる処理の並列化は逆効果になる可能性がある
5. 例外処理を適切に行う：スレッド内で発生した例外を適切にハンドリングする

## 7. パフォーマンスとデバッグ

1. Visual Studioの並列スタックウィンドウを活用する
2. パフォーマンスプロファイラを使用して並列処理の効率を測定する
3. デバッグ時にスレッドの切り替えに注意を払う

## 8. 新しい並列処理パターン

1. TPL Dataflow：データ処理パイプラインの構築に適している
2. Reactive Extensions (Rx)：非同期データストリームの処理に適している

---
# WPFでの実装の参考リンク
## テーマ設定
- [[WPF] Windows 10に馴染むテーマを適用する #Windows10 - Qiita](https://qiita.com/Kosen-amai/items/607b9ba3af9222aa7225)

## ホットキーの設定
- [c#でのホットキー設定方法 #C# - Qiita](https://qiita.com/niwanowa/items/7328a438f38e9b0bdd81)

## タスクトレイ
- [WPFでタスクトレイ常駐アプリを作る #C# - Qiita](https://qiita.com/TiggeZaki/items/aa17edbef0cc5f4736d9)
